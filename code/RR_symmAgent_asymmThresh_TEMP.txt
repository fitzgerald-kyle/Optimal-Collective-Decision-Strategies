function RR = RR_symmAgent_asymmThresh2(p, X, TI, N)
% Calculates expected reward rate for two agents in consecutive
% environments with random probability of positive or negative associated
% drift, where decisions are separated by time TI. Agents are "symmetric"
% in the sense that they set decision thresholds at the same (possibly
% asymmetric) values, they receive the same (possibly asymmetric) "kick" 
% from the other agent when it is the first to decide at a boundary, and
% they receive the same (possibly asymmetric) reward upon decision at the
% boundary that matches the drift of the current environment. For 
% simplicity, we assume that agents are in a mu=1 or mu=-1 environment each
% with probability 1/2. Due to agent symmetry, WLOG we perform all
% calculations for one agent, conditioning on the other agent deciding 
% first if applicable. N is the number of image terms to use in the
% probability densities that solve the Focker-Planck equation.

% set parameters contained in 'X' explicitly for maximization routine
p = parameters('p', p, 'H1', X(1), 'L1', X(2), 'qp1', X(3), 'qn1', X(4));

% compute when fH and fL are "sufficiently small"
%{
tic;
fthresh = 1e-6; opts = optimset('tolx',1e-8); len = 100;
[tmax,~] = fminsearch(@(t) -fH(t,1,p,N), 1e-3, opts);
tf = tmax;
while fH(tf,1,p,N) > fthresh% || fH(tH_P,1,p,N) > fH(tH_P-.01,1,p,N)
    tf = tf + tmax;
end; tHPpts = [linspace(0,4*tmax,len) linspace(4*tmax,tf,len)];
[tmax,~] = fminsearch(@(t) -fH(t,-1,p,N), 1e-3, opts);
tf = tmax;
while fH(tf,-1,p,N) > fthresh% || fH(tH_N,-1,p,N) > fH(tH_N-.01,-1,p,N)
    tf = tf + tmax;
end; tHNpts = [linspace(0,4*tmax,len) linspace(4*tmax,tf,len)];
[tmax,~] = fminsearch(@(t) -fL(t,1,p,N), 1e-3, opts);
tf = tmax;
while fL(tf,1,p,N) > fthresh% || fL(tL_P,1,p,N) > fL(tL_P-.01,1,p,N)
    tf = tf + tmax;
end; tLPpts = [linspace(0,4*tmax,len) linspace(4*tmax,tf,len)];
[tmax,~] = fminsearch(@(t) -fL(t,-1,p,N), 1e-3, opts);
tf = tmax;
while fL(tf,-1,p,N) > fthresh% || fL(tL_N,-1,p,N) > fL(tL_N-.01,-1,p,N)
    tf = tf + tmax;
end; tLNpts = [linspace(0,4*tmax,len) linspace(4*tmax,tf,len)];
T=toc;
%}
%tic;
r = exp_reward(p, N);
%T=toc;
TL = exp_TL(p, N);
RR = 2*r / (TL + TI); 
end

function r = exp_reward(p, N)
% Expected reward for each agent across all environments, WLOG agent 1.

% compute some helpful values so we don't have to recompute them a lot
%fH_cond_inf_P = zeros(length(tHPpts),1); fH_cond_inf_N = fH_cond_inf_P;
%fL_cond_inf_P = fH_cond_inf_P; fL_cond_inf_N = fH_cond_inf_P;
%tic;
%fInt_P = sum(LagWts.*(fH(LagRoots,1,p,N)+fL(LagRoots,1,p,N)).*exp(LagRoots));
%fInt_N = sum(LagWts.*(fH(LagRoots,-1,p,N)+fL(LagRoots,-1,p,N)).*exp(LagRoots));
%for i= 1:length(tHPpts)
    %temp_P = fInt_P; temp_N = fInt_N;
    %[tpts,twts] = lgwt(1000,LagRoots(i),1); % assume there's basically nothing after t=10
    %fInt_P = sum( twts.*(fH(tpts,1,p,N)+fL(tpts,1,p,N)) );
    %fInt_P = trapz(tHPpts(i:end),fH(tHPpts(i:end),1,p,N))+trapz(tLPpts,fL(tLPpts,1,p,N));
%    fHInt_P = integral(@(t) fH(t,1,p,N)+fL(t,1,p,N),tHPpts(i),tHPpts(end),'AbsTol',1e-9,'RelTol',1e-6);
%    fHInt_N = integral(@(t) fH(t,-1,p,N)+fL(t,-1,p,N),tHNpts(i),tHNpts(end),'AbsTol',1e-9,'RelTol',1e-6);
%    fLInt_P = integral(@(t) fH(t,1,p,N)+fL(t,1,p,N),tLPpts(i),tLPpts(end),'AbsTol',1e-9,'RelTol',1e-6);
%    fLInt_N = integral(@(t) fH(t,-1,p,N)+fL(t,-1,p,N),tLNpts(i),tLNpts(end),'AbsTol',1e-9,'RelTol',1e-6);
    %fInt_N = sum( twts.*(fH(tpts,-1,p,N)+fL(tpts,-1,p,N)) );
    %fInt_N = trapz(tHNpts,fH(tHNpts,-1,p,N))+trapz(tLNpts,fL(tLNpts,-1,p,N));
    %fInt_N = integral(@(t) fH(t,-1,p,N)+fL(t,-1,p,N),LagRoots(i),inf,'AbsTol',1e-9,'RelTol',1e-6);
%    fH_cond_inf_P(i) = fH(tHPpts(i),1,p,N) .* fHInt_P;
%    fH_cond_inf_N(i) = fH(tHNpts(i),-1,p,N) .* fHInt_N;
%    fL_cond_inf_P(i) = fL(tLPpts(i),1,p,N) .* fLInt_P;
%    fL_cond_inf_N(i) = fL(tLNpts(i),-1,p,N) .* fLInt_N;
    %fInt_P = temp_P; fInt_N = temp_N;
%end
%T=toc;
%[xpts,LegWts] = lgwt(50,p.L1,p.H1);
fH_cond_inf_P = @(t1,t2) fH(t1,1,p,N).*(fH(t2,1,p,N)+fL(t2,1,p,N));
fL_cond_inf_P = @(t1,t2) fL(t1,1,p,N).*(fH(t2,1,p,N)+fL(t2,1,p,N));
fH_cond_inf_N = @(t1,t2) fH(t1,-1,p,N).*(fH(t2,-1,p,N)+fL(t2,-1,p,N));
fL_cond_inf_N = @(t1,t2) fL(t1,-1,p,N).*(fH(t2,-1,p,N)+fL(t2,-1,p,N));
epsH_P = @(x) (exp(-x.*p.D)-exp(-p.L1.*p.D)) ./ (exp(-p.H1.*p.D)-exp(-p.L1.*p.D));
epsL_N = @(x) (exp(p.H1.*p.D)-exp(x.*p.D)) ./ (exp(p.H1.*p.D)-exp(p.L1.*p.D));

probAtUpper = 1/2 * ( P_crossBefore(fH_cond_inf_P) + ...
    P_instCrossAfter(p, fH_cond_inf_P, p.H1, 1, N) + ...
    P_diffCrossAfter(p, fH_cond_inf_P, fL_cond_inf_P, epsH_P, 1, N) );
probAtLower = 1/2 * ( P_crossBefore(fL_cond_inf_N) + ...
    P_instCrossAfter(p, fL_cond_inf_N, p.L1, -1, N) + ...
    P_diffCrossAfter(p, fH_cond_inf_N, fL_cond_inf_N, epsL_N, -1, N) );

r = p.R1p/2 * probAtUpper + p.R1n/2 * probAtLower;
end

function TL = exp_TL(p, N)
% Expected time for the last agent to make a decision (WLOG for agent 2 to
% decide, conditioned on agent 1 deciding first).

%fvalsHP = zeros(length(tHPpts),1); fvalsHN = fvalsHP; fvalsLP = fvalsHP; fvalsLN = fvalsHP;
%tic;
%for i=1:length(tHPpts)
    %[tpts,twts] = lgwt(max(50,round(LagRoots(i))*4),0,LagRoots(i));
    %fvalsP(i) = (fH(LagRoots(i),1,p,N)+fL(LagRoots(i),1,p,N)) ...
    %    .* sum( twts.*(fH(tpts,1,p,N)+fL(tpts,1,p,N)) );
    %fvalsN(i) = (fH(LagRoots(i),-1,p,N)+fL(LagRoots(i),-1,p,N)) ...
    %    .* sum( twts.*(fH(tpts,-1,p,N)+fL(tpts,-1,p,N)) );
    %fvalsP(i) = (fH(LagRoots(i),1,p,N)+fL(LagRoots(i),1,p,N)) ...
    %    .* integral(@(t) fH(t,1,p,N)+fL(t,1,p,N),0,LagRoots(i),'AbsTol',1e-9,'RelTol',1e-6);
    %fvalsN(i) = (fH(LagRoots(i),-1,p,N)+fL(LagRoots(i),-1,p,N)) ...
    %    .* integral(@(t) fH(t,-1,p,N)+fL(t,-1,p,N),0,LagRoots(i),'AbsTol',1e-9,'RelTol',1e-6);
%    fHInt_P = integral(@(t) fH(t,1,p,N)+fL(t,1,p,N),0,tHPpts(i),'AbsTol',1e-9,'RelTol',1e-6);
%    fHInt_N = integral(@(t) fH(t,-1,p,N)+fL(t,-1,p,N),0,tHNpts(i),'AbsTol',1e-9,'RelTol',1e-6);
%    fLInt_P = integral(@(t) fH(t,1,p,N)+fL(t,1,p,N),0,tLPpts(i),'AbsTol',1e-9,'RelTol',1e-6);
%    fLInt_N = integral(@(t) fH(t,-1,p,N)+fL(t,-1,p,N),0,tLNpts(i),'AbsTol',1e-9,'RelTol',1e-6);
%    fvalsHP(i) = fH(tHPpts(i),1,p,N) .* fHInt_P;
%    fvalsHN(i) = fH(tHNpts(i),-1,p,N) .* fHInt_N;
%    fvalsLP(i) = fL(tLPpts(i),1,p,N) .* fLInt_P;
%    fvalsLN(i) = fL(tLNpts(i),-1,p,N) .* fLInt_N;
%end
%T=toc;
%tic;
tf = 10;
TL = integral2(@(t1,t2) t1.*fH(t1,1,p,N).*fH(t2,1,p,N),0,tf,0,@(t1)t1,'AbsTol',1e-6) + ...
    integral2(@(t1,t2) t1.*fH(t1,1,p,N).*fL(t2,1,p,N),0,tf,0,@(t1)t1,'AbsTol',1e-6) + ...
    integral2(@(t1,t2) t1.*fL(t1,1,p,N).*fH(t2,1,p,N),0,tf,0,@(t1)t1,'AbsTol',1e-6) + ...
    integral2(@(t1,t2) t1.*fL(t1,1,p,N).*fL(t2,1,p,N),0,tf,0,@(t1)t1,'AbsTol',1e-6) + ...
    integral2(@(t1,t2) t1.*fH(t1,-1,p,N).*fH(t2,-1,p,N),0,tf,0,@(t1)t1,'AbsTol',1e-6) + ...
    integral2(@(t1,t2) t1.*fH(t1,-1,p,N).*fL(t2,-1,p,N),0,tf,0,@(t1)t1,'AbsTol',1e-6) + ...
    integral2(@(t1,t2) t1.*fL(t1,-1,p,N).*fH(t2,-1,p,N),0,tf,0,@(t1)t1,'AbsTol',1e-6) + ...
    integral2(@(t1,t2) t1.*fL(t1,-1,p,N).*fL(t2,-1,p,N),0,tf,0,@(t1)t1,'AbsTol',1e-6);
%TL = integral2(@(t1,t2) t1.*((fH(t1,1,p,N)+fL(t1,1,p,N)).*(fH(t2,1,p,N)+fL(t2,1,p,N)) + ...
%    (fH(t1,-1,p,N)+fL(t1,-1,p,N)).*(fH(t2,-1,p,N)+fL(t2,-1,p,N))), ...
%    0,tf,0,@(t1)t1,'AbsTol',1e-6);
%TL = integral2(@(t1,t2) t1.*(fH(t1,1,p,N)+fL(t1,1,p,N)).*(fH(t2,1,p,N)+fL(t2,1,p,N)), ...
%    0,tf,0,@(t1)t1,'AbsTol',1e-6) + ...
%    integral2(@(t1,t2) t1.*(fH(t1,-1,p,N)+fL(t1,-1,p,N)).*(fH(t2,-1,p,N)+fL(t2,-1,p,N)), ...
%    0,tf,0,@(t1)t1,'AbsTol',1e-6);
%T4 = toc
%TL = 1/2 * sum(LagWts.*LagRoots.*fvalsP.*exp(LagRoots)) / ...
%    sum(LagWts.*fvalsP.*exp(LagRoots)) + ...
%    1/2 * sum(LagWts.*LagRoots.*fvalsN.*exp(LagRoots)) / ...
%    sum(LagWts.*fvalsN.*exp(LagRoots));
end

function P = P_crossBefore(fthresh_cond_inf)
% Probability that one agent crosses the decision threshold at "thresh",
% given that it decides before the other agent.
%tic;
tf = 10;%inf;
P = integral2(@(t1,t2) fthresh_cond_inf(t1,t2),0,tf,@(t1)t1,tf,'AbsTol',1e-6);
%T1 = toc
%P = sum(LagWts.*fthresh_cond_inf.*exp(LagRoots));
end

function P = P_instCrossAfter(p, fthresh_cond_inf, thresh, mu, N)
% Probability that one agent is instantaneously "kicked" across the 
% decision threshold at "thresh", given the other agent's crossing of 
% "thresh" before.
%rhoInt = zeros(length(LagRoots),1);
%for i=1:length(LagRoots)
%    if sign(thresh) == 1
%        rhoInt(i) = (intc(p,thresh,LagRoots(i),1,N,'mu',mu) ...
%            - intc(p,thresh-p.qp1,LagRoots(i),1,N,'mu',mu)) ./ rhoDenom(LagRoots(i),mu,p,N);
%    elseif sign(thresh) == -1
%        rhoInt(i) = (intc(p,thresh+p.qn1,LagRoots(i),1,N,'mu',mu) ...
%            - intc(p,thresh,LagRoots(i),1,N,'mu',mu)) ./ rhoDenom(LagRoots(i),mu,p,N);
%    end
%end
%P = sum(LagWts.*fthresh_cond_inf.*rhoInt.*exp(LagRoots));
%tic;
tf = 10;%inf;
if sign(thresh) == 1
    P = integral2(@(t1,t2) fthresh_cond_inf(t1,t2).*(intc(p,thresh,t1,1,N,mu) ...
        - intc(p,thresh-p.qp1,t1,1,N,mu)) ./ rhoDenom(t1,mu,p,N), ...
        0,tf,@(t1)t1,tf,'AbsTol',1e-6);
elseif sign(thresh) == -1
    P = integral2(@(t1,t2) fthresh_cond_inf(t1,t2).*(intc(p,thresh+p.qn1,t1,1,N,mu) ...
        - intc(p,thresh,t1,1,N,mu)) ./ rhoDenom(t1,mu,p,N), ...
        0,tf,@(t1)t1,tf,'AbsTol',1e-6);
end
%T2 = toc

end

function P = P_diffCrossAfter(p, fH_cond_inf, fL_cond_inf, epsFun, mu, N)
% Probability that one agent diffuses across the decision threshold at 
% "thresh", given the other agent's crossing of one of the thresholds before.
%rhoInt1 = zeros(length(LagRoots),1); rhoInt2 = rhoInt1; epsInt = rhoInt1; 
%for i=1:length(LagRoots)
%    denom = rhoDenom(LagRoots(i),mu,p,N);
%    rhoInt1(i) = (intc(p,p.H1-p.qp1,LagRoots(i),1,N,'mu',mu) - ...
%        intc(p,p.L1,LagRoots(i),1,N,'mu',mu)) ./ denom;
%    rhoInt2(i) = (intc(p,p.H1,LagRoots(i),1,N,'mu',mu) - ...
%        intc(p,p.L1+p.qn1,LagRoots(i),1,N,'mu',mu)) ./ denom;
%    epsInt(i) = sum(LegWts.*c(p,xpts,LagRoots(i),1,N,'mu',mu).*epsFun) ...
%        ./ denom;
%end
%P = sum(LagWts.*fH_cond_inf.*rhoInt1.*epsInt.*exp(LagRoots)) + ...
%    sum(LagWts.*fL_cond_inf.*rhoInt2.*epsInt.*exp(LagRoots));
%tic;
%xpts = linspace(p.L1,p.H1,50)'; 
tf = 10;
P = integral2(@(t1,t2) fH_cond_inf(t1,t2).*(intc(p,p.H1-p.qp1,t1,1,N,mu) - ...
        intc(p,p.L1,t1,1,N,mu)) ./ rhoDenom(t1,mu,p,N).^2 .* ...
        integral(@(x) c(p,x,t1,1,N,mu).*epsFun(x),p.L1,p.H1,'ArrayValued',1), ...
        0,tf,@(t1)t1,tf,'AbsTol',1e-6) + ...
        integral2(@(t1,t2) fL_cond_inf(t1,t2).*(intc(p,p.H1,t1,1,N,mu) - ...
        intc(p,p.L1+p.qn1,t1,1,N,mu)) ./ rhoDenom(t1,mu,p,N).^2 .* ...
        integral(@(x) c(p,x,t1,1,N,mu).*epsFun(x),p.L1,p.H1,'ArrayValued',1), ...
        0,tf,@(t1)t1,tf,'AbsTol',1e-6);
%T3 = toc
end

function val = fH(t,mu,p,N)
    val = -p.D * dcdx(p,p.H1,t,1,N,mu);
end

function val = fL(t,mu,p,N)
    val = p.D * dcdx(p,p.L1,t,1,N,mu);
end

function val = rhoDenom(t,mu,p,N)
    val = intc(p,p.H1,t,1,N,mu) - intc(p,p.L1,t,1,N,mu);
    if abs(val)==0, val = eps; end
end

function [x,w]=lgwt(N,a,b)
% https://www.mathworks.com/matlabcentral/fileexchange/4540-legendre-gauss-quadrature
% -weights-and-nodes
%
% This script is for computing definite integrals using Legendre-Gauss 
% Quadrature. Computes the Legendre-Gauss nodes and weights  on an interval
% [a,b] with truncation order N
%
% Suppose you have a continuous function f(x) which is defined on [a,b]
% which you can evaluate at any x in [a,b]. Simply evaluate it at all of
% the values contained in the x vector to obtain a vector f. Then compute
% the definite integral using sum(f.*w);
%
% Written by Greg von Winckel - 02/25/2004
N=N-1;
N1=N+1; N2=N+2;
xu=linspace(-1,1,N1)';
% Initial guess
y=cos((2*(0:N)'+1)*pi/(2*N+2))+(0.27/N1)*sin(pi*xu*N/N2);
% Legendre-Gauss Vandermonde Matrix
L=zeros(N1,N2);
% Derivative of LGVM
Lp=zeros(N1,N2);
% Compute the zeros of the N+1 Legendre Polynomial
% using the recursion relation and the Newton-Raphson method
y0=2;
% Iterate until new points are uniformly within epsilon of old points
while max(abs(y-y0))>eps
    
    
    L(:,1)=1;
    
    L(:,2)=y;
    
    for k=2:N1
        L(:,k+1)=( (2*k-1)*y.*L(:,k)-(k-1)*L(:,k-1) )/k;
    end
 
    Lp=(N2)*( L(:,N1)-y.*L(:,N2) )./(1-y.^2);   
    
    y0=y;
    y=y0-L(:,N2)./Lp;
    
end
% Linear map from[-1,1] to [a,b]
x=(a*(1-y)+b*(1+y))/2;      
% Compute the weights
w=(b-a)./((1-y.^2).*Lp.^2)*(N2/N1)^2;
end